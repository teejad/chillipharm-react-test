{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createHover = createHover;\n\nvar _invariant = require(\"@react-dnd/invariant\");\n\nvar _matchesTypeJs = require(\"../../utils/matchesType.js\");\n\nvar _typesJs = require(\"./types.js\");\n\nfunction createHover(manager) {\n  return function hover(targetIdsArg) {\n    let {\n      clientOffset\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    verifyTargetIdsIsArray(targetIdsArg);\n    const targetIds = targetIdsArg.slice(0);\n    const monitor = manager.getMonitor();\n    const registry = manager.getRegistry();\n    checkInvariants(targetIds, monitor, registry);\n    const draggedItemType = monitor.getItemType();\n    removeNonMatchingTargetIds(targetIds, registry, draggedItemType);\n    hoverAllTargets(targetIds, monitor, registry);\n    return {\n      type: _typesJs.HOVER,\n      payload: {\n        targetIds,\n        clientOffset: clientOffset || null\n      }\n    };\n  };\n}\n\nfunction verifyTargetIdsIsArray(targetIdsArg) {\n  (0, _invariant).invariant(Array.isArray(targetIdsArg), 'Expected targetIds to be an array.');\n}\n\nfunction checkInvariants(targetIds, monitor, registry) {\n  (0, _invariant).invariant(monitor.isDragging(), 'Cannot call hover while not dragging.');\n  (0, _invariant).invariant(!monitor.didDrop(), 'Cannot call hover after drop.');\n\n  for (let i = 0; i < targetIds.length; i++) {\n    const targetId = targetIds[i];\n    (0, _invariant).invariant(targetIds.lastIndexOf(targetId) === i, 'Expected targetIds to be unique in the passed array.');\n    const target = registry.getTarget(targetId);\n    (0, _invariant).invariant(target, 'Expected targetIds to be registered.');\n  }\n}\n\nfunction removeNonMatchingTargetIds(targetIds, registry, draggedItemType) {\n  // Remove those targetIds that don't match the targetType.  This\n  // fixes shallow isOver which would only be non-shallow because of\n  // non-matching targets.\n  for (let i = targetIds.length - 1; i >= 0; i--) {\n    const targetId = targetIds[i];\n    const targetType = registry.getTargetType(targetId);\n\n    if (!(0, _matchesTypeJs).matchesType(targetType, draggedItemType)) {\n      targetIds.splice(i, 1);\n    }\n  }\n}\n\nfunction hoverAllTargets(targetIds, monitor, registry) {\n  // Finally call hover on all matching targets.\n  targetIds.forEach(function (targetId) {\n    const target = registry.getTarget(targetId);\n    target.hover(monitor, targetId);\n  });\n}","map":{"version":3,"mappings":";;;;;QAagBA;;AAbU,cAAsB,kCAAtB;;AAUE,kBAA4B,wCAA5B;;AACN,YAAY,wBAAZ;;SAENA,YAAYC,SAA0B;AACrD,SAAO,SAASC,KAAT,CACNC,YADM,EAGiB;AAAA,QADvB;AAAEC;AAAF,KACuB,uEADU,EACV;AACvBC,0BAAsB,CAACF,YAAD,CAAtBE;AACA,UAAMC,SAAS,GAAGH,YAAY,CAACI,KAAbJ,CAAmB,CAAnBA,CAAlB;AACA,UAAMK,OAAO,GAAGP,OAAO,CAACQ,UAARR,EAAhB;AACA,UAAMS,QAAQ,GAAGT,OAAO,CAACU,WAARV,EAAjB;AACAW,mBAAe,CAACN,SAAD,EAAYE,OAAZ,EAAqBE,QAArB,CAAfE;AACA,UAAMC,eAAe,GAAGL,OAAO,CAACM,WAARN,EAAxB;AACAO,8BAA0B,CAACT,SAAD,EAAYI,QAAZ,EAAsBG,eAAtB,CAA1BE;AACAC,mBAAe,CAACV,SAAD,EAAYE,OAAZ,EAAqBE,QAArB,CAAfM;AAEA,WAAO;AACNC,UAAI,EAAEC,QAAK,MADL;AAENC,aAAO,EAAE;AACRb,iBADQ;AAERF,oBAAY,EAAEA,YAAY,IAAI;AAFtB;AAFH,KAAP;AAOA,GApBD;AAqBA;;SAEQC,uBAAuBF,cAAwB;MACvDiB,YAASA,UAACC,KAAK,CAACC,OAAND,CAAclB,YAAdkB,GAA6B;AACvC;;SAEQT,gBACRN,WACAE,SACAE,UACC;MACDU,YAASA,UAACZ,OAAO,CAACe,UAARf,IAAsB;MAChCY,YAASA,WAAEZ,OAAO,CAACgB,OAARhB,IAAmB;;AAC9B,OAAK,IAAIiB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGnB,SAAS,CAACoB,MAA9B,EAAsCD,CAAC,EAAvC,EAA2C;AAC1C,UAAME,QAAQ,GAAGrB,SAAS,CAACmB,CAAD,CAA1B;QACAL,YAASA,UACRd,SAAS,CAACsB,WAAVtB,CAAsBqB,QAAtBrB,MAAoCmB,GACpC;AAGD,UAAMI,MAAM,GAAGnB,QAAQ,CAACoB,SAATpB,CAAmBiB,QAAnBjB,CAAf;QACAU,YAASA,UAACS,QAAQ;AAClB;AACD;;SAEQd,2BACRT,WACAI,UACAG,iBACC;AACD;AACA;AACA;AACA,OAAK,IAAIY,CAAC,GAAGnB,SAAS,CAACoB,MAAVpB,GAAmB,CAAhC,EAAmCmB,CAAC,IAAI,CAAxC,EAA2CA,CAAC,EAA5C,EAAgD;AAC/C,UAAME,QAAQ,GAAGrB,SAAS,CAACmB,CAAD,CAA1B;AACA,UAAMM,UAAU,GAAGrB,QAAQ,CAACsB,aAATtB,CAAuBiB,QAAvBjB,CAAnB;;AACA,QAAE,KAAGuB,cAAH,EAAcA,WAAd,CAAeF,UAAf,EAA2BlB,eAA3B,CAAF,EAA+C;AAC9CP,eAAS,CAAC4B,MAAV5B,CAAiBmB,CAAjBnB,EAAoB,CAApBA;AACA;AACD;AACD;;SAEQU,gBACRV,WACAE,SACAE,UACC;AACD;AACAJ,WAAS,CAAC6B,OAAV7B,CAAkB,UAAUqB,QAAV,EAAoB;AACrC,UAAME,MAAM,GAAGnB,QAAQ,CAACoB,SAATpB,CAAmBiB,QAAnBjB,CAAf;AACAmB,UAAM,CAAC3B,KAAP2B,CAAarB,OAAbqB,EAAsBF,QAAtBE;AACA,GAHDvB;AAIA","names":["createHover","manager","hover","targetIdsArg","clientOffset","verifyTargetIdsIsArray","targetIds","slice","monitor","getMonitor","registry","getRegistry","checkInvariants","draggedItemType","getItemType","removeNonMatchingTargetIds","hoverAllTargets","type","HOVER","payload","invariant","Array","isArray","isDragging","didDrop","i","length","targetId","lastIndexOf","target","getTarget","targetType","getTargetType","matchesType","splice","forEach"],"sources":["/Users/davidandtiana/Downloads/chillibean-test/node_modules/dnd-core/src/actions/dragDrop/hover.ts"],"sourcesContent":["import { invariant } from '@react-dnd/invariant'\nimport type {\n\tAction,\n\tDragDropManager,\n\tHoverPayload,\n\tHoverOptions,\n\tDragDropMonitor,\n\tHandlerRegistry,\n\tIdentifier,\n} from '../../interfaces.js'\nimport { matchesType } from '../../utils/matchesType.js'\nimport { HOVER } from './types.js'\n\nexport function createHover(manager: DragDropManager) {\n\treturn function hover(\n\t\ttargetIdsArg: string[],\n\t\t{ clientOffset }: HoverOptions = {},\n\t): Action<HoverPayload> {\n\t\tverifyTargetIdsIsArray(targetIdsArg)\n\t\tconst targetIds = targetIdsArg.slice(0)\n\t\tconst monitor = manager.getMonitor()\n\t\tconst registry = manager.getRegistry()\n\t\tcheckInvariants(targetIds, monitor, registry)\n\t\tconst draggedItemType = monitor.getItemType()\n\t\tremoveNonMatchingTargetIds(targetIds, registry, draggedItemType)\n\t\thoverAllTargets(targetIds, monitor, registry)\n\n\t\treturn {\n\t\t\ttype: HOVER,\n\t\t\tpayload: {\n\t\t\t\ttargetIds,\n\t\t\t\tclientOffset: clientOffset || null,\n\t\t\t},\n\t\t}\n\t}\n}\n\nfunction verifyTargetIdsIsArray(targetIdsArg: string[]) {\n\tinvariant(Array.isArray(targetIdsArg), 'Expected targetIds to be an array.')\n}\n\nfunction checkInvariants(\n\ttargetIds: string[],\n\tmonitor: DragDropMonitor,\n\tregistry: HandlerRegistry,\n) {\n\tinvariant(monitor.isDragging(), 'Cannot call hover while not dragging.')\n\tinvariant(!monitor.didDrop(), 'Cannot call hover after drop.')\n\tfor (let i = 0; i < targetIds.length; i++) {\n\t\tconst targetId = targetIds[i] as string\n\t\tinvariant(\n\t\t\ttargetIds.lastIndexOf(targetId) === i,\n\t\t\t'Expected targetIds to be unique in the passed array.',\n\t\t)\n\n\t\tconst target = registry.getTarget(targetId)\n\t\tinvariant(target, 'Expected targetIds to be registered.')\n\t}\n}\n\nfunction removeNonMatchingTargetIds(\n\ttargetIds: string[],\n\tregistry: HandlerRegistry,\n\tdraggedItemType: Identifier | null,\n) {\n\t// Remove those targetIds that don't match the targetType.  This\n\t// fixes shallow isOver which would only be non-shallow because of\n\t// non-matching targets.\n\tfor (let i = targetIds.length - 1; i >= 0; i--) {\n\t\tconst targetId = targetIds[i] as string\n\t\tconst targetType = registry.getTargetType(targetId)\n\t\tif (!matchesType(targetType, draggedItemType)) {\n\t\t\ttargetIds.splice(i, 1)\n\t\t}\n\t}\n}\n\nfunction hoverAllTargets(\n\ttargetIds: string[],\n\tmonitor: DragDropMonitor,\n\tregistry: HandlerRegistry,\n) {\n\t// Finally call hover on all matching targets.\n\ttargetIds.forEach(function (targetId) {\n\t\tconst target = registry.getTarget(targetId)\n\t\ttarget.hover(monitor, targetId)\n\t})\n}\n"]},"metadata":{},"sourceType":"script"}