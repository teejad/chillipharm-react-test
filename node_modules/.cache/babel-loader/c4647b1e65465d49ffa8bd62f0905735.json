{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getNodeClientOffset = getNodeClientOffset;\nexports.getEventClientOffset = getEventClientOffset;\nexports.getDragPreviewOffset = getDragPreviewOffset;\n\nvar _browserDetectorJs = require(\"./BrowserDetector.js\");\n\nvar _monotonicInterpolantJs = require(\"./MonotonicInterpolant.js\");\n\nconst ELEMENT_NODE = 1;\n\nfunction getNodeClientOffset(node) {\n  const el = node.nodeType === ELEMENT_NODE ? node : node.parentElement;\n\n  if (!el) {\n    return null;\n  }\n\n  const {\n    top,\n    left\n  } = el.getBoundingClientRect();\n  return {\n    x: left,\n    y: top\n  };\n}\n\nfunction getEventClientOffset(e) {\n  return {\n    x: e.clientX,\n    y: e.clientY\n  };\n}\n\nfunction isImageNode(node) {\n  var ref;\n  return node.nodeName === 'IMG' && ((0, _browserDetectorJs).isFirefox() || !((ref = document.documentElement) === null || ref === void 0 ? void 0 : ref.contains(node)));\n}\n\nfunction getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight) {\n  let dragPreviewWidth = isImage ? dragPreview.width : sourceWidth;\n  let dragPreviewHeight = isImage ? dragPreview.height : sourceHeight; // Work around @2x coordinate discrepancies in browsers\n\n  if ((0, _browserDetectorJs).isSafari() && isImage) {\n    dragPreviewHeight /= window.devicePixelRatio;\n    dragPreviewWidth /= window.devicePixelRatio;\n  }\n\n  return {\n    dragPreviewWidth,\n    dragPreviewHeight\n  };\n}\n\nfunction getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint) {\n  // The browsers will use the image intrinsic size under different conditions.\n  // Firefox only cares if it's an image, but WebKit also wants it to be detached.\n  const isImage = isImageNode(dragPreview);\n  const dragPreviewNode = isImage ? sourceNode : dragPreview;\n  const dragPreviewNodeOffsetFromClient = getNodeClientOffset(dragPreviewNode);\n  const offsetFromDragPreview = {\n    x: clientOffset.x - dragPreviewNodeOffsetFromClient.x,\n    y: clientOffset.y - dragPreviewNodeOffsetFromClient.y\n  };\n  const {\n    offsetWidth: sourceWidth,\n    offsetHeight: sourceHeight\n  } = sourceNode;\n  const {\n    anchorX,\n    anchorY\n  } = anchorPoint;\n  const {\n    dragPreviewWidth,\n    dragPreviewHeight\n  } = getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight);\n\n  const calculateYOffset = () => {\n    const interpolantY = new _monotonicInterpolantJs.MonotonicInterpolant([0, 0.5, 1], [// Dock to the top\n    offsetFromDragPreview.y, // Align at the center\n    offsetFromDragPreview.y / sourceHeight * dragPreviewHeight, // Dock to the bottom\n    offsetFromDragPreview.y + dragPreviewHeight - sourceHeight]);\n    let y = interpolantY.interpolate(anchorY); // Work around Safari 8 positioning bug\n\n    if ((0, _browserDetectorJs).isSafari() && isImage) {\n      // We'll have to wait for @3x to see if this is entirely correct\n      y += (window.devicePixelRatio - 1) * dragPreviewHeight;\n    }\n\n    return y;\n  };\n\n  const calculateXOffset = () => {\n    // Interpolate coordinates depending on anchor point\n    // If you know a simpler way to do this, let me know\n    const interpolantX = new _monotonicInterpolantJs.MonotonicInterpolant([0, 0.5, 1], [// Dock to the left\n    offsetFromDragPreview.x, // Align at the center\n    offsetFromDragPreview.x / sourceWidth * dragPreviewWidth, // Dock to the right\n    offsetFromDragPreview.x + dragPreviewWidth - sourceWidth]);\n    return interpolantX.interpolate(anchorX);\n  }; // Force offsets if specified in the options.\n\n\n  const {\n    offsetX,\n    offsetY\n  } = offsetPoint;\n  const isManualOffsetX = offsetX === 0 || offsetX;\n  const isManualOffsetY = offsetY === 0 || offsetY;\n  return {\n    x: isManualOffsetX ? offsetX : calculateXOffset(),\n    y: isManualOffsetY ? offsetY : calculateYOffset()\n  };\n}","map":{"version":3,"mappings":";;;;;QAMgBA;QAWAC;QA+BAC;;AAhDoB,sBAAsB,kCAAtB;;AACC,2BAA2B,uCAA3B;;AAGrC,MAAMC,YAAY,GAAG,CAArB;;SAEgBH,oBAAoBI,MAA4B;AAC/D,QAAMC,EAAE,GAAGD,IAAI,CAACE,QAALF,KAAkBD,YAAlBC,GAAiCA,IAAjCA,GAAwCA,IAAI,CAACG,aAAxD;;AAEA,MAAE,CAAGF,EAAL,EAAS;AACR,WAAO,IAAP;AACA;;AAED,QAAM;AAAEG,OAAF;AAAOC;AAAP,MAAiBJ,EAAE,CAAiBK,qBAAnBL,EAAvB;AACA,SAAO;AAAEM,KAAC,EAAEF,IAAL;AAAWG,KAAC,EAAEJ;AAAd,GAAP;AACA;;SAEeP,qBAAqBY,GAAwB;AAC5D,SAAO;AACNF,KAAC,EAAEE,CAAC,CAACC,OADC;AAENF,KAAC,EAAEC,CAAC,CAACE;AAFC,GAAP;AAIA;;SAEQC,YAAYZ,MAAW;MAGba;AAFlB,SACCb,IAAI,CAACc,QAALd,KAAkB,KAAlBA,KAAuB,IACtBe,kBADsB,EACbA,SADa,MACb,GAAOF,GAAwB,GAAxBA,QAAQ,CAACG,eAAhB,MAA+B,IAA/B,IAAOH,GAAwB,KAAxBA,MAAP,GAAOA,MAAP,GAAOA,GAAwB,CAAEI,QAA1BJ,CAAmCb,IAAnCa,CAAP,CADVb,CADD;AAIA;;SAEQkB,mBACRC,SACAC,aACAC,aACAC,cACC;AACD,MAAIC,gBAAgB,GAAGJ,OAAO,GAAGC,WAAW,CAACI,KAAf,GAAuBH,WAArD;AACA,MAAII,iBAAiB,GAAGN,OAAO,GAAGC,WAAW,CAACM,MAAf,GAAwBJ,YAAvD,CAFC,CAID;;AACA,MAAE,IAAEK,kBAAF,EAAUA,QAAV,MAAgBR,OAAlB,EAA2B;AAC1BM,qBAAiB,IAAIG,MAAM,CAACC,gBAA5BJ;AACAF,oBAAgB,IAAIK,MAAM,CAACC,gBAA3BN;AACA;;AACD,SAAO;AAAEA,oBAAF;AAAoBE;AAApB,GAAP;AACA;;SAEe3B,qBACfgC,YACAV,aACAW,cACAC,aACAC,aACU;AACV;AACA;AACA,QAAMd,OAAO,GAAGP,WAAW,CAACQ,WAAD,CAA3B;AACA,QAAMc,eAAe,GAAGf,OAAO,GAAGW,UAAH,GAAgBV,WAA/C;AACA,QAAMe,+BAA+B,GAAGvC,mBAAmB,CAC1DsC,eAD0D,CAA3D;AAGA,QAAME,qBAAqB,GAAG;AAC7B7B,KAAC,EAAEwB,YAAY,CAACxB,CAAbwB,GAAiBI,+BAA+B,CAAC5B,CADvB;AAE7BC,KAAC,EAAEuB,YAAY,CAACvB,CAAbuB,GAAiBI,+BAA+B,CAAC3B;AAFvB,GAA9B;AAIA,QAAM;AAAE6B,eAAW,EAAEhB,WAAf;AAA4BiB,gBAAY,EAAEhB;AAA1C,MAA2DQ,UAAjE;AACA,QAAM;AAAES,WAAF;AAAWC;AAAX,MAAuBR,WAA7B;AACA,QAAM;AAAET,oBAAF;AAAoBE;AAApB,MAA0CP,kBAAkB,CACjEC,OADiE,EAEjEC,WAFiE,EAGjEC,WAHiE,EAIjEC,YAJiE,CAAlE;;AAOA,QAAMmB,gBAAgB,SAAS;AAC9B,UAAMC,YAAY,GAAG,IAAIC,uBAAoB,qBAAxB,CACpB,CAAC,CAAD,EAAI,GAAJ,EAAS,CAAT,CADoB,EAEpB,CACC;AACAP,yBAAqB,CAAC5B,CAFvB,EAGC;AACC4B,yBAAqB,CAAC5B,CAAtB4B,GAA0Bd,eAAgBG,iBAJ5C,EAKC;AACAW,yBAAqB,CAAC5B,CAAtB4B,GAA0BX,iBAA1BW,GAA8Cd,YAN/C,CAFoB,CAArB;AAWA,QAAId,CAAC,GAAGkC,YAAY,CAACE,WAAbF,CAAyBF,OAAzBE,CAAR,CAZ8B,CAa9B;;AACA,QAAE,IAAEf,kBAAF,EAAUA,QAAV,MAAgBR,OAAlB,EAA2B;AAC1B;AACAX,OAAC,KAAKoB,MAAM,CAACC,gBAAPD,GAA0B,CAA/B,IAAoCH,iBAArCjB;AACA;;AACD,WAAOA,CAAP;AACA,GAnBD;;AAqBA,QAAMqC,gBAAgB,SAAS;AAC9B;AACA;AACA,UAAMC,YAAY,GAAG,IAAIH,uBAAoB,qBAAxB,CACpB,CAAC,CAAD,EAAI,GAAJ,EAAS,CAAT,CADoB,EAEpB,CACC;AACAP,yBAAqB,CAAC7B,CAFvB,EAGC;AACC6B,yBAAqB,CAAC7B,CAAtB6B,GAA0Bf,cAAeE,gBAJ3C,EAKC;AACAa,yBAAqB,CAAC7B,CAAtB6B,GAA0Bb,gBAA1Ba,GAA6Cf,WAN9C,CAFoB,CAArB;AAWA,WAAOyB,YAAY,CAACF,WAAbE,CAAyBP,OAAzBO,CAAP;AACA,GAfD,CA1CU,CA2DV;;;AACA,QAAM;AAAEC,WAAF;AAAWC;AAAX,MAAuBf,WAA7B;AACA,QAAMgB,eAAe,GAAGF,OAAO,KAAK,CAAZA,IAAiBA,OAAzC;AACA,QAAMG,eAAe,GAAGF,OAAO,KAAK,CAAZA,IAAiBA,OAAzC;AACA,SAAO;AACNzC,KAAC,EAAE0C,eAAe,GAAGF,OAAH,GAAaF,gBAAgB,EADzC;AAENrC,KAAC,EAAE0C,eAAe,GAAGF,OAAH,GAAaP,gBAAgB;AAFzC,GAAP;AAIA","names":["getNodeClientOffset","getEventClientOffset","getDragPreviewOffset","ELEMENT_NODE","node","el","nodeType","parentElement","top","left","getBoundingClientRect","x","y","e","clientX","clientY","isImageNode","document","nodeName","isFirefox","documentElement","contains","getDragPreviewSize","isImage","dragPreview","sourceWidth","sourceHeight","dragPreviewWidth","width","dragPreviewHeight","height","isSafari","window","devicePixelRatio","sourceNode","clientOffset","anchorPoint","offsetPoint","dragPreviewNode","dragPreviewNodeOffsetFromClient","offsetFromDragPreview","offsetWidth","offsetHeight","anchorX","anchorY","calculateYOffset","interpolantY","MonotonicInterpolant","interpolate","calculateXOffset","interpolantX","offsetX","offsetY","isManualOffsetX","isManualOffsetY"],"sources":["/Users/davidandtiana/Downloads/chillibean-test/node_modules/react-dnd-html5-backend/src/OffsetUtils.ts"],"sourcesContent":["import { isSafari, isFirefox } from './BrowserDetector.js'\nimport { MonotonicInterpolant } from './MonotonicInterpolant.js'\nimport type { XYCoord } from 'dnd-core'\n\nconst ELEMENT_NODE = 1\n\nexport function getNodeClientOffset(node: Node): XYCoord | null {\n\tconst el = node.nodeType === ELEMENT_NODE ? node : node.parentElement\n\n\tif (!el) {\n\t\treturn null\n\t}\n\n\tconst { top, left } = (el as HTMLElement).getBoundingClientRect()\n\treturn { x: left, y: top }\n}\n\nexport function getEventClientOffset(e: MouseEvent): XYCoord {\n\treturn {\n\t\tx: e.clientX,\n\t\ty: e.clientY,\n\t}\n}\n\nfunction isImageNode(node: any) {\n\treturn (\n\t\tnode.nodeName === 'IMG' &&\n\t\t(isFirefox() || !document.documentElement?.contains(node))\n\t)\n}\n\nfunction getDragPreviewSize(\n\tisImage: boolean,\n\tdragPreview: any,\n\tsourceWidth: number,\n\tsourceHeight: number,\n) {\n\tlet dragPreviewWidth = isImage ? dragPreview.width : sourceWidth\n\tlet dragPreviewHeight = isImage ? dragPreview.height : sourceHeight\n\n\t// Work around @2x coordinate discrepancies in browsers\n\tif (isSafari() && isImage) {\n\t\tdragPreviewHeight /= window.devicePixelRatio\n\t\tdragPreviewWidth /= window.devicePixelRatio\n\t}\n\treturn { dragPreviewWidth, dragPreviewHeight }\n}\n\nexport function getDragPreviewOffset(\n\tsourceNode: HTMLElement,\n\tdragPreview: HTMLElement,\n\tclientOffset: XYCoord,\n\tanchorPoint: { anchorX: number; anchorY: number },\n\toffsetPoint: { offsetX: number; offsetY: number },\n): XYCoord {\n\t// The browsers will use the image intrinsic size under different conditions.\n\t// Firefox only cares if it's an image, but WebKit also wants it to be detached.\n\tconst isImage = isImageNode(dragPreview)\n\tconst dragPreviewNode = isImage ? sourceNode : dragPreview\n\tconst dragPreviewNodeOffsetFromClient = getNodeClientOffset(\n\t\tdragPreviewNode,\n\t) as XYCoord\n\tconst offsetFromDragPreview = {\n\t\tx: clientOffset.x - dragPreviewNodeOffsetFromClient.x,\n\t\ty: clientOffset.y - dragPreviewNodeOffsetFromClient.y,\n\t}\n\tconst { offsetWidth: sourceWidth, offsetHeight: sourceHeight } = sourceNode\n\tconst { anchorX, anchorY } = anchorPoint\n\tconst { dragPreviewWidth, dragPreviewHeight } = getDragPreviewSize(\n\t\tisImage,\n\t\tdragPreview,\n\t\tsourceWidth,\n\t\tsourceHeight,\n\t)\n\n\tconst calculateYOffset = () => {\n\t\tconst interpolantY = new MonotonicInterpolant(\n\t\t\t[0, 0.5, 1],\n\t\t\t[\n\t\t\t\t// Dock to the top\n\t\t\t\toffsetFromDragPreview.y,\n\t\t\t\t// Align at the center\n\t\t\t\t(offsetFromDragPreview.y / sourceHeight) * dragPreviewHeight,\n\t\t\t\t// Dock to the bottom\n\t\t\t\toffsetFromDragPreview.y + dragPreviewHeight - sourceHeight,\n\t\t\t],\n\t\t)\n\t\tlet y = interpolantY.interpolate(anchorY)\n\t\t// Work around Safari 8 positioning bug\n\t\tif (isSafari() && isImage) {\n\t\t\t// We'll have to wait for @3x to see if this is entirely correct\n\t\t\ty += (window.devicePixelRatio - 1) * dragPreviewHeight\n\t\t}\n\t\treturn y\n\t}\n\n\tconst calculateXOffset = () => {\n\t\t// Interpolate coordinates depending on anchor point\n\t\t// If you know a simpler way to do this, let me know\n\t\tconst interpolantX = new MonotonicInterpolant(\n\t\t\t[0, 0.5, 1],\n\t\t\t[\n\t\t\t\t// Dock to the left\n\t\t\t\toffsetFromDragPreview.x,\n\t\t\t\t// Align at the center\n\t\t\t\t(offsetFromDragPreview.x / sourceWidth) * dragPreviewWidth,\n\t\t\t\t// Dock to the right\n\t\t\t\toffsetFromDragPreview.x + dragPreviewWidth - sourceWidth,\n\t\t\t],\n\t\t)\n\t\treturn interpolantX.interpolate(anchorX)\n\t}\n\n\t// Force offsets if specified in the options.\n\tconst { offsetX, offsetY } = offsetPoint\n\tconst isManualOffsetX = offsetX === 0 || offsetX\n\tconst isManualOffsetY = offsetY === 0 || offsetY\n\treturn {\n\t\tx: isManualOffsetX ? offsetX : calculateXOffset(),\n\t\ty: isManualOffsetY ? offsetY : calculateYOffset(),\n\t}\n}\n"]},"metadata":{},"sourceType":"script"}