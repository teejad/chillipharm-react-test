{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.wrapConnectorHooks = wrapConnectorHooks;\n\nvar _invariant = require(\"@react-dnd/invariant\");\n\nvar _react = require(\"react\");\n\nfunction throwIfCompositeComponentElement(element) {\n  // Custom components can no longer be wrapped directly in React DnD 2.0\n  // so that we don't need to depend on findDOMNode() from react-dom.\n  if (typeof element.type === 'string') {\n    return;\n  }\n\n  const displayName = element.type.displayName || element.type.name || 'the component';\n  throw new Error('Only native element nodes can now be passed to React DnD connectors.' + `You can either wrap ${displayName} into a <div>, or turn it into a ` + 'drag source or a drop target itself.');\n}\n\nfunction wrapHookToRecognizeElement(hook) {\n  return function () {\n    let elementOrNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    // When passed a node, call the hook straight away.\n    if (!(0, _react).isValidElement(elementOrNode)) {\n      const node = elementOrNode;\n      hook(node, options); // return the node so it can be chained (e.g. when within callback refs\n      // <div ref={node => connectDragSource(connectDropTarget(node))}/>\n\n      return node;\n    } // If passed a ReactElement, clone it and attach this function as a ref.\n    // This helps us achieve a neat API where user doesn't even know that refs\n    // are being used under the hood.\n\n\n    const element = elementOrNode;\n    throwIfCompositeComponentElement(element); // When no options are passed, use the hook directly\n\n    const ref = options ? node => hook(node, options) : hook;\n    return cloneWithRef(element, ref);\n  };\n}\n\nfunction wrapConnectorHooks(hooks) {\n  const wrappedHooks = {};\n  Object.keys(hooks).forEach(key => {\n    const hook = hooks[key]; // ref objects should be passed straight through without wrapping\n\n    if (key.endsWith('Ref')) {\n      wrappedHooks[key] = hooks[key];\n    } else {\n      const wrappedHook = wrapHookToRecognizeElement(hook);\n\n      wrappedHooks[key] = () => wrappedHook;\n    }\n  });\n  return wrappedHooks;\n}\n\nfunction setRef(ref, node) {\n  if (typeof ref === 'function') {\n    ref(node);\n  } else {\n    ref.current = node;\n  }\n}\n\nfunction cloneWithRef(element, newRef) {\n  const previousRef = element.ref;\n  (0, _invariant).invariant(typeof previousRef !== 'string', 'Cannot connect React DnD to an element with an existing string ref. ' + 'Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. ' + 'Read more: https://reactjs.org/docs/refs-and-the-dom.html#callback-refs');\n\n  if (!previousRef) {\n    // When there is no ref on the element, use the new ref directly\n    return (0, _react).cloneElement(element, {\n      ref: newRef\n    });\n  } else {\n    return (0, _react).cloneElement(element, {\n      ref: node => {\n        setRef(previousRef, node);\n        setRef(newRef, node);\n      }\n    });\n  }\n}","map":{"version":3,"mappings":";;;;;QA2CgBA;;AA3CU,cAAsB,kCAAtB;;AACiC,UAAO,mBAAP;;SAElDC,iCAAiCC,SAA4B;AACrE;AACA;AACA,MAAI,OAAOA,OAAO,CAACC,IAAf,KAAwB,QAA5B,EAAsC;AACrC;AACA;;AAED,QAAMC,WAAW,GACfF,OAAO,CAACC,IAARD,CAAqBE,WAArBF,IAAoCA,OAAO,CAACC,IAARD,CAAaG,IAAjDH,IAAyD,eAD3D;AAGA,QAAM,IAAII,KAAJ,CACL,yEACE,uBAAsBF,WAAY,mCADpC,GAEC,sCAHI,CAAN;AAKA;;SAEQG,2BAA2BC,MAAyC;AAC5E,SAAM,YAA2C;AAAA,QAAzCC,aAAyC,uEAAzB,IAAyB;AAAA,QAAnBC,OAAmB,uEAAT,IAAS;;AAChD;AACA,QAAE,KAAGC,MAAH,EAAiBA,cAAjB,CAAkBF,aAAlB,CAAF,EAAoC;AACnC,YAAMG,IAAI,GAAGH,aAAb;AACAD,UAAI,CAACI,IAAD,EAAOF,OAAP,CAAJF,CAFmC,CAGnC;AACA;;AACA,aAAOI,IAAP;AACA,KAR+C,CAUhD;AACA;AACA;;;AACA,UAAMV,OAAO,GAAwBO,aAArC;AACAR,oCAAgC,CAACC,OAAD,CAAhCD,CAdgD,CAgBhD;;AACA,UAAMY,GAAG,GAAGH,OAAO,GAAIE,IAAJ,IAAsBJ,IAAI,CAACI,IAAD,EAAOF,OAAP,CAA1B,GAA4CF,IAA/D;AACA,WAAOM,YAAY,CAACZ,OAAD,EAAUW,GAAV,CAAnB;AACA,GAnBD;AAoBA;;SAEeb,mBAAmBe,OAAY;AAC9C,QAAMC,YAAY,GAAQ,EAA1B;AAEAC,QAAM,CAACC,IAAPD,CAAYF,KAAZE,EAAmBE,OAAnBF,CAA4BG,GAAF,IAAU;AACnC,UAAMZ,IAAI,GAAGO,KAAK,CAACK,GAAD,CAAlB,CADmC,CAGnC;;AACA,QAAIA,GAAG,CAACC,QAAJD,CAAa,KAAbA,CAAJ,EAAyB;AACxBJ,kBAAY,CAACI,GAAD,CAAZJ,GAAoBD,KAAK,CAACK,GAAD,CAAzBJ;AACA,KAFD,MAEO;AACN,YAAMM,WAAW,GAAGf,0BAA0B,CAACC,IAAD,CAA9C;;AACAQ,kBAAY,CAACI,GAAD,CAAZJ,GAAgB,MAAUM,WAA1BN;AACA;AACD,GAVDC;AAYA,SAAOD,YAAP;AACA;;SAEQO,OAAOV,KAAUD,MAAW;AACpC,MAAI,OAAOC,GAAP,KAAe,UAAnB,EAA+B;AAC9BA,OAAG,CAACD,IAAD,CAAHC;AACA,GAFD,MAEO;AACNA,OAAG,CAACW,OAAJX,GAAcD,IAAdC;AACA;AACD;;SAEQC,aAAaZ,SAAcuB,QAAgC;AACnE,QAAMC,WAAW,GAAGxB,OAAO,CAACW,GAA5B;MACAc,YAASA,UACR,OAAOD,WAAP,KAAuB,UACvB,yEACC,sFADD,GAEC;;AAGF,MAAE,CAAGA,WAAL,EAAkB;AACjB;AACA,WAAM,IAACE,MAAD,EAAaA,YAAb,CAAc1B,OAAd,EAAuB;AAC5BW,SAAG,EAAEY;AADuB,KAAvB,CAAN;AAGA,GALD,MAKO;AACN,WAAM,IAACG,MAAD,EAAaA,YAAb,CAAc1B,OAAd,EAAuB;AAC5BW,SAAG,EAAGD,IAAH,IAAiB;AACnBW,cAAM,CAACG,WAAD,EAAcd,IAAd,CAANW;AACAA,cAAM,CAACE,MAAD,EAASb,IAAT,CAANW;AACA;AAJ2B,KAAvB,CAAN;AAMA;AACD","names":["wrapConnectorHooks","throwIfCompositeComponentElement","element","type","displayName","name","Error","wrapHookToRecognizeElement","hook","elementOrNode","options","isValidElement","node","ref","cloneWithRef","hooks","wrappedHooks","Object","keys","forEach","key","endsWith","wrappedHook","setRef","current","newRef","previousRef","invariant","cloneElement"],"sources":["/Users/davidandtiana/Downloads/chillibean-test/node_modules/react-dnd/src/internals/wrapConnectorHooks.ts"],"sourcesContent":["import { invariant } from '@react-dnd/invariant'\nimport { cloneElement, isValidElement, ReactElement } from 'react'\n\nfunction throwIfCompositeComponentElement(element: ReactElement<any>) {\n\t// Custom components can no longer be wrapped directly in React DnD 2.0\n\t// so that we don't need to depend on findDOMNode() from react-dom.\n\tif (typeof element.type === 'string') {\n\t\treturn\n\t}\n\n\tconst displayName =\n\t\t(element.type as any).displayName || element.type.name || 'the component'\n\n\tthrow new Error(\n\t\t'Only native element nodes can now be passed to React DnD connectors.' +\n\t\t\t`You can either wrap ${displayName} into a <div>, or turn it into a ` +\n\t\t\t'drag source or a drop target itself.',\n\t)\n}\n\nfunction wrapHookToRecognizeElement(hook: (node: any, options: any) => void) {\n\treturn (elementOrNode = null, options = null) => {\n\t\t// When passed a node, call the hook straight away.\n\t\tif (!isValidElement(elementOrNode)) {\n\t\t\tconst node = elementOrNode\n\t\t\thook(node, options)\n\t\t\t// return the node so it can be chained (e.g. when within callback refs\n\t\t\t// <div ref={node => connectDragSource(connectDropTarget(node))}/>\n\t\t\treturn node\n\t\t}\n\n\t\t// If passed a ReactElement, clone it and attach this function as a ref.\n\t\t// This helps us achieve a neat API where user doesn't even know that refs\n\t\t// are being used under the hood.\n\t\tconst element: ReactElement | null = elementOrNode\n\t\tthrowIfCompositeComponentElement(element as any)\n\n\t\t// When no options are passed, use the hook directly\n\t\tconst ref = options ? (node: Element) => hook(node, options) : hook\n\t\treturn cloneWithRef(element, ref)\n\t}\n}\n\nexport function wrapConnectorHooks(hooks: any) {\n\tconst wrappedHooks: any = {}\n\n\tObject.keys(hooks).forEach((key) => {\n\t\tconst hook = hooks[key]\n\n\t\t// ref objects should be passed straight through without wrapping\n\t\tif (key.endsWith('Ref')) {\n\t\t\twrappedHooks[key] = hooks[key]\n\t\t} else {\n\t\t\tconst wrappedHook = wrapHookToRecognizeElement(hook)\n\t\t\twrappedHooks[key] = () => wrappedHook\n\t\t}\n\t})\n\n\treturn wrappedHooks\n}\n\nfunction setRef(ref: any, node: any) {\n\tif (typeof ref === 'function') {\n\t\tref(node)\n\t} else {\n\t\tref.current = node\n\t}\n}\n\nfunction cloneWithRef(element: any, newRef: any): ReactElement<any> {\n\tconst previousRef = element.ref\n\tinvariant(\n\t\ttypeof previousRef !== 'string',\n\t\t'Cannot connect React DnD to an element with an existing string ref. ' +\n\t\t\t'Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. ' +\n\t\t\t'Read more: https://reactjs.org/docs/refs-and-the-dom.html#callback-refs',\n\t)\n\n\tif (!previousRef) {\n\t\t// When there is no ref on the element, use the new ref directly\n\t\treturn cloneElement(element, {\n\t\t\tref: newRef,\n\t\t})\n\t} else {\n\t\treturn cloneElement(element, {\n\t\t\tref: (node: any) => {\n\t\t\t\tsetRef(previousRef, node)\n\t\t\t\tsetRef(newRef, node)\n\t\t\t},\n\t\t})\n\t}\n}\n"]},"metadata":{},"sourceType":"script"}