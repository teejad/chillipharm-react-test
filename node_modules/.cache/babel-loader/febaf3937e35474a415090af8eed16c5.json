{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DndProvider = void 0;\n\nvar _jsxRuntime = require(\"react/jsx-runtime\");\n\nvar _react = require(\"react\");\n\nvar _dndCore = require(\"dnd-core\");\n\nvar _dndContextJs = require(\"./DndContext.js\");\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nlet refCount = 0;\nconst INSTANCE_SYM = Symbol.for('__REACT_DND_CONTEXT_INSTANCE__');\nvar DndProvider = /*#__PURE__*/(0, _react).memo(function DndProvider(_param) {\n  var {\n    children\n  } = _param,\n      props = _objectWithoutProperties(_param, [\"children\"]);\n\n  const [manager, isGlobalInstance] = getDndContextValue(props) // memoized from props\n  ;\n  /**\n  * If the global context was used to store the DND context\n  * then where theres no more references to it we should\n  * clean it up to avoid memory leaks\n  */\n\n  (0, _react).useEffect(() => {\n    if (isGlobalInstance) {\n      const context = getGlobalContext();\n      ++refCount;\n      return () => {\n        if (--refCount === 0) {\n          context[INSTANCE_SYM] = null;\n        }\n      };\n    }\n\n    return;\n  }, []);\n  return /*#__PURE__*/(0, _jsxRuntime).jsx(_dndContextJs.DndContext.Provider, {\n    value: manager,\n    children: children\n  });\n});\nexports.DndProvider = DndProvider;\n\nfunction getDndContextValue(props) {\n  if ('manager' in props) {\n    const manager = {\n      dragDropManager: props.manager\n    };\n    return [manager, false];\n  }\n\n  const manager = createSingletonDndContext(props.backend, props.context, props.options, props.debugMode);\n  const isGlobalInstance = !props.context;\n  return [manager, isGlobalInstance];\n}\n\nfunction createSingletonDndContext(backend) {\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getGlobalContext();\n  let options = arguments.length > 2 ? arguments[2] : undefined;\n  let debugMode = arguments.length > 3 ? arguments[3] : undefined;\n  const ctx = context;\n\n  if (!ctx[INSTANCE_SYM]) {\n    ctx[INSTANCE_SYM] = {\n      dragDropManager: (0, _dndCore).createDragDropManager(backend, context, options, debugMode)\n    };\n  }\n\n  return ctx[INSTANCE_SYM];\n}\n\nfunction getGlobalContext() {\n  return typeof global !== 'undefined' ? global : window;\n}","map":{"version":3,"mappings":";;;;;;;;;AAA+C,UAAO,mBAAP;;AAKxC,YAAU,sBAAV;;AACoB,iBAAiB,6BAAjB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAe3B,IAAIA,QAAQ,GAAG,CAAf;AACA,MAAMC,YAAY,GAAGC,MAAM,CAACC,GAAPD,CAAW,gCAAXA,CAArB;IAKaE,WAAW,oBAA2CC,MAA3C,EAA+CA,IAA/C,CACvB,SAASD,WAAT,CAAqBE,MAArB,EAA6C;MAAxB;AAAEC;AAAF;MAAeC,KAAK,4BAApBF,MAAoB,EAAE,CAApBC,UAAoB,CAAF;;AACxC,QAAK,CAAEE,OAAF,EAAWC,gBAAX,IAA+BC,kBAAkB,CAACH,KAAD,CAAtD,CAAoF;AAApF;AACA;;;;;;AAIG,MACHI,MADG,EACMA,SADN,CACM,MAAO;AACf,QAAIF,gBAAJ,EAAsB;AACrB,YAAMG,OAAO,GAAGC,gBAAgB,EAAhC;QACEd;AAEF,aAAM,MAAO;AACZ,YAAE,EAAIA,QAAJ,KAAiB,CAAnB,EAAsB;AACrBa,iBAAO,CAACZ,YAAD,CAAPY,GAAwB,IAAxBA;AACA;AACD,OAJD;AAKA;;AACD;AACA,GAbE,EAaA,EAbA;AAeH,SAAM,kCAAEE,aAAU,WAAVA,CAAWC,QAAb,EAAqB;AAACC,SAAK,EAAER,OAAR;cAAkBF;AAAlB,GAArB,CAAN;AACA,CAvBsB;;;SA0BfI,mBAAmBH,OAA2C;AACtE,MAAI,aAAaA,KAAjB,EAAwB;AACvB,UAAMC,OAAO,GAAG;AAAES,qBAAe,EAAEV,KAAK,CAACC;AAAzB,KAAhB;AACA,WAAO,CAACA,OAAD,EAAU,KAAV,CAAP;AACA;;AAED,QAAMA,OAAO,GAAGU,yBAAyB,CACxCX,KAAK,CAACY,OADkC,EAExCZ,KAAK,CAACK,OAFkC,EAGxCL,KAAK,CAACa,OAHkC,EAIxCb,KAAK,CAACc,SAJkC,CAAzC;AAMA,QAAMZ,gBAAgB,IAAIF,KAAK,CAACK,OAAhC;AAEA,SAAO,CAACJ,OAAD,EAAUC,gBAAV,CAAP;AACA;;SAEQS,0BACRC,SAIC;AAAA,MAHDP,OAGC,uEAHyBC,gBAAgB,EAGzC;AAAA,MAFDO,OAEC;AAAA,MADDC,SACC;AACD,QAAMC,GAAG,GAAGV,OAAZ;;AACA,MAAE,CAAGU,GAAG,CAACtB,YAAD,CAAR,EAAwB;AACvBsB,OAAG,CAACtB,YAAD,CAAHsB,GAAoB;AACnBL,qBAAe,MAAEM,QAAF,EAAuBA,qBAAvB,CACdJ,OADc,EAEdP,OAFc,EAGdQ,OAHc,EAIdC,SAJc;AADI,KAApBC;AAQA;;AACD,SAAOA,GAAG,CAACtB,YAAD,CAAV;AACA;;SAGQa,mBAAmB;AAC3B,SAAO,OAAOW,MAAP,KAAkB,WAAlB,GAAgCA,MAAhC,GAA0CC,MAAjD;AACA","names":["refCount","INSTANCE_SYM","Symbol","for","DndProvider","memo","_param","children","props","manager","isGlobalInstance","getDndContextValue","useEffect","context","getGlobalContext","DndContext","Provider","value","dragDropManager","createSingletonDndContext","backend","options","debugMode","ctx","createDragDropManager","global","window"],"sources":["/Users/davidandtiana/Downloads/chillibean-test/node_modules/react-dnd/src/core/DndProvider.tsx"],"sourcesContent":["import { FC, useEffect, memo, ReactNode } from 'react'\nimport {\n\tBackendFactory,\n\tDragDropManager,\n\tcreateDragDropManager,\n} from 'dnd-core'\nimport { DndContext } from './DndContext.js'\n\nexport type DndProviderProps<BackendContext, BackendOptions> =\n\t| {\n\t\t\tchildren?: ReactNode\n\t\t\tmanager: DragDropManager\n\t  }\n\t| {\n\t\t\tbackend: BackendFactory\n\t\t\tchildren?: ReactNode\n\t\t\tcontext?: BackendContext\n\t\t\toptions?: BackendOptions\n\t\t\tdebugMode?: boolean\n\t  }\n\nlet refCount = 0\nconst INSTANCE_SYM = Symbol.for('__REACT_DND_CONTEXT_INSTANCE__')\n\n/**\n * A React component that provides the React-DnD context\n */\nexport const DndProvider: FC<DndProviderProps<unknown, unknown>> = memo(\n\tfunction DndProvider({ children, ...props }) {\n\t\tconst [manager, isGlobalInstance] = getDndContextValue(props) // memoized from props\n\t\t/**\n\t\t * If the global context was used to store the DND context\n\t\t * then where theres no more references to it we should\n\t\t * clean it up to avoid memory leaks\n\t\t */\n\t\tuseEffect(() => {\n\t\t\tif (isGlobalInstance) {\n\t\t\t\tconst context = getGlobalContext()\n\t\t\t\t++refCount\n\n\t\t\t\treturn () => {\n\t\t\t\t\tif (--refCount === 0) {\n\t\t\t\t\t\tcontext[INSTANCE_SYM] = null\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn\n\t\t}, [])\n\n\t\treturn <DndContext.Provider value={manager}>{children}</DndContext.Provider>\n\t},\n)\n\nfunction getDndContextValue(props: DndProviderProps<unknown, unknown>) {\n\tif ('manager' in props) {\n\t\tconst manager = { dragDropManager: props.manager }\n\t\treturn [manager, false]\n\t}\n\n\tconst manager = createSingletonDndContext(\n\t\tprops.backend,\n\t\tprops.context,\n\t\tprops.options,\n\t\tprops.debugMode,\n\t)\n\tconst isGlobalInstance = !props.context\n\n\treturn [manager, isGlobalInstance]\n}\n\nfunction createSingletonDndContext<BackendContext, BackendOptions>(\n\tbackend: BackendFactory,\n\tcontext: BackendContext = getGlobalContext(),\n\toptions: BackendOptions,\n\tdebugMode?: boolean,\n) {\n\tconst ctx = context as any\n\tif (!ctx[INSTANCE_SYM]) {\n\t\tctx[INSTANCE_SYM] = {\n\t\t\tdragDropManager: createDragDropManager(\n\t\t\t\tbackend,\n\t\t\t\tcontext,\n\t\t\t\toptions,\n\t\t\t\tdebugMode,\n\t\t\t),\n\t\t}\n\t}\n\treturn ctx[INSTANCE_SYM]\n}\n\ndeclare const global: any\nfunction getGlobalContext() {\n\treturn typeof global !== 'undefined' ? global : (window as any)\n}\n"]},"metadata":{},"sourceType":"script"}